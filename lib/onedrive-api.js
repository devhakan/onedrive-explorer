const axios = require('axios');
const fs = require('fs');

class OneDriveAPI {
  constructor() {
    this.accessToken = process.env.ACCESS_TOKEN;
    this.refreshToken = process.env.REFRESH_TOKEN;
    this.driveId = process.env.DRIVE_ID;
    this.clientId = process.env.CLIENT_ID;
    this.tenantId = process.env.TENANT_ID;
    this.configName = process.env.RCLONE_CONFIG_NAME;
    this.baseUrl = 'https://graph.microsoft.com/v1.0';
    this.tokenExpiry = null;
    this.lastRefreshTime = 0; // Son yenileme zamanƒ±
    
    // Token s√ºresini kontrol et
    this.checkTokenExpiry();
  }

  /**
   * Token s√ºresini kontrol et ve gerekirse yenile
   */
  checkTokenExpiry() {
    try {
      if (!this.accessToken) return;
      
      // JWT token'ƒ± decode et
      const parts = this.accessToken.split('.');
      if (parts.length !== 3) return;
      
      const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());
      this.tokenExpiry = new Date(payload.exp * 1000);
      
      // Token 10 dakika i√ßinde sona eriyorsa yenile
      const now = new Date();
      const tenMinutesFromNow = new Date(now.getTime() + 10 * 60 * 1000);
      
      if (this.tokenExpiry <= tenMinutesFromNow) {
        // Son yenilemeden bu yana en az 30 saniye ge√ßmi≈ü olmalƒ±
        const now = Date.now();
        if (now - this.lastRefreshTime > 30000) {
          console.log('‚ö†Ô∏è Token s√ºresi dolmak √ºzere, rclone\'dan g√ºncel token alƒ±nƒ±yor...');
          this.refreshTokenFromRclone();
        }
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Token s√ºresi kontrol edilemedi:', error.message);
    }
  }

  /**
   * Rclone'dan g√ºncel token'ƒ± al ve .env dosyasƒ±nƒ± g√ºncelle
   */
  async refreshTokenFromRclone() {
    try {
      // Yenileme zamanƒ±nƒ± kaydet
      this.lastRefreshTime = Date.now();
      
      const { execSync } = require('child_process');
      const configOutput = execSync('rclone config dump', { encoding: 'utf8' });
      const config = JSON.parse(configOutput);
      
      // Mevcut config ismini kullanarak g√ºncel token'ƒ± al
      const configName = this.configName || 'sy-1'; // Varsayƒ±lan olarak sy-1
      
      if (config[configName] && config[configName].token) {
        const tokenData = JSON.parse(config[configName].token);
        
        // Yeni token'larƒ± g√ºncelle
        this.accessToken = tokenData.access_token;
        this.refreshToken = tokenData.refresh_token;
        
        // Process environment'ƒ±nƒ± da g√ºncelle
        process.env.ACCESS_TOKEN = tokenData.access_token;
        process.env.REFRESH_TOKEN = tokenData.refresh_token;
        
        // .env dosyasƒ±nƒ± g√ºncelle
        this.updateEnvFile({
          accessToken: tokenData.access_token,
          refreshToken: tokenData.refresh_token,
          driveId: this.driveId,
          clientId: this.clientId,
          tenantId: this.tenantId,
          configName: configName,
          expiry: tokenData.expiry
        });
        
        console.log('‚úÖ Token ba≈üarƒ±yla yenilendi!');
        
        // Yeni token s√ºresi kontrol√º
        this.checkTokenExpiry();
        
        return true;
      } else {
        throw new Error(`Rclone config'inde "${configName}" bulunamadƒ±`);
      }
    } catch (error) {
      console.error('‚ùå Token yenileme hatasƒ±:', error.message);
      return false;
    }
  }

  /**
   * .env dosyasƒ±nƒ± g√ºncelle
   */
  updateEnvFile(envData) {
    try {
      const envContent = `# OneDrive Business hesap bilgileri (rclone config dump ile otomatik olu≈üturuldu)
# ACCESS_TOKEN ve REFRESH_TOKEN alanlarƒ±na SADECE JWT (noktalƒ±, uzun string) yazƒ±lƒ±r.
ACCESS_TOKEN=${envData.accessToken}
REFRESH_TOKEN=${envData.refreshToken}
DRIVE_ID=${envData.driveId}
CLIENT_ID=${envData.clientId || 'token-icinde-bulunamadi'}
TENANT_ID=${envData.tenantId || 'token-icinde-bulunamadi'}
RCLONE_CONFIG_NAME=${envData.configName}

# Token biti≈ü tarihi: ${envData.expiry || 'Bilinmiyor'}
# Son g√ºncelleme: ${new Date().toISOString()}
`;
      fs.writeFileSync('.env', envContent);
      console.log('‚úÖ .env dosyasƒ± g√ºncellendi.');
    } catch (error) {
      console.error('‚ùå .env dosyasƒ± g√ºncellenirken hata:', error.message);
    }
  }

  /**
   * API √ßaƒürƒ±sƒ± yap ve hata durumunda token yenile
   */
  async makeApiCall(url, options = {}) {
    try {
      const response = await axios({
        url,
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json',
          ...options.headers
        },
        ...options
      });
      return response;
    } catch (error) {
      // 401 Unauthorized hatasƒ± varsa token yenile
      if (error.response?.status === 401) {
        // Son yenilemeden bu yana en az 30 saniye ge√ßmi≈ü olmalƒ±
        const now = Date.now();
        if (now - this.lastRefreshTime > 30000) {
          console.log('üîÑ Token ge√ßersiz, yenileniyor...');
          const refreshed = await this.refreshTokenFromRclone();
          
          if (refreshed) {
            // Token yenilenirse tekrar dene
            const retryResponse = await axios({
              url,
              headers: {
                'Authorization': `Bearer ${this.accessToken}`,
                'Content-Type': 'application/json',
                ...options.headers
              },
              ...options
            });
            return retryResponse;
          }
        } else {
          console.log('‚ö†Ô∏è Token yakƒ±n zamanda yenilendi, tekrar denenmeyecek');
        }
      }
      throw error;
    }
  }

  /**
   * Drive alan bilgilerini al
   */
  async getDriveInfo() {
    try {
      const url = `${this.baseUrl}/me/drive`;
      const response = await this.makeApiCall(url);
      const quota = response.data.quota;
      return {
        total: quota?.total || 0,
        used: quota?.used || 0,
        remaining: quota?.remaining || 0
      };
    } catch (error) {
      throw error;
    }
  }

  /**
   * JWT token'dan kullanƒ±cƒ± e-posta adƒ±nƒ± √ßƒ±kar
   */
  getEmailFromToken() {
    try {
      if (!this.accessToken) return 'Bilinmiyor';
      
      // JWT token'ƒ± decode et
      const parts = this.accessToken.split('.');
      if (parts.length !== 3) return 'Bilinmiyor';
      
      // Payload'ƒ± decode et
      const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());
      
      // E-posta bilgisini bul
      const email = payload.upn || payload.preferred_username || payload.email || payload.name;
      
      return email || 'Bilinmiyor';
    } catch (error) {
      return 'Bilinmiyor';
    }
  }

  /**
   * .env dosyasƒ±ndan rclone config ismini al
   */
  getEmailFromRcloneConfig() {
    try {
      // √ñnce .env dosyasƒ±ndan config ismini almaya √ßalƒ±≈ü
      if (process.env.RCLONE_CONFIG_NAME) {
        return process.env.RCLONE_CONFIG_NAME;
      }
      
      // Fallback: rclone config dump ile ilk OneDrive config'ini bul
      const { execSync } = require('child_process');
      const configOutput = execSync('rclone config dump', { encoding: 'utf8' });
      const config = JSON.parse(configOutput);
      
      // sy-1, sy-2, sy-3 gibi OneDrive konfig√ºrasyonlarƒ±nƒ± bul
      const oneDriveConfigs = Object.entries(config)
        .filter(([, config]) => config.type === 'onedrive')
        .map(([name, config]) => ({ name, config }));
      
      if (oneDriveConfigs.length > 0) {
        // ƒ∞lk OneDrive konfig√ºrasyonunu kullan
        const config = oneDriveConfigs[0];
        return config.name; // sy-1, sy-2 gibi
      }
      
      return 'Bilinmiyor';
    } catch (error) {
      return 'Bilinmiyor';
    }
  }

  formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * Dosya arama
   */
  async searchFiles(query, type = null, limit = 50) {
    try {
      let url = `${this.baseUrl}/me/drive/root/search(q='${encodeURIComponent(query)}')`;
      const response = await this.makeApiCall(url);
      let items = response.data.value || [];
      if (type) {
        const archiveTypes = ['zip', 'tar', 'tar.gz', 'gz', 'rar'];
        if (type === 'folder') {
          items = items.filter(item => item.folder);
        } else if (type === 'archive') {
          items = items.filter(item => {
            if (item.folder) return false;
            const ext = require('./utils').getFileExtension(item.name);
            return archiveTypes.includes(ext);
          });
        } else if (archiveTypes.includes(type)) {
          items = items.filter(item => {
            if (item.folder) return false;
            const ext = require('./utils').getFileExtension(item.name);
            return ext === type;
          });
        } else {
          items = items.filter(item => {
            if (item.folder) return false;
            return item.name.toLowerCase().endsWith(type.toLowerCase());
          });
        }
      }
      return {
        total: items.length,
        items: items.slice(0, limit)
      };
    } catch (error) {
      throw error;
    }
  }

  /**
   * Klas√∂r i√ßeriƒüi listele
   */
  async listFolder(folderId = 'root', limit = 50) {
    try {
      const url = `${this.baseUrl}/me/drive/items/${folderId}/children`;
      const response = await this.makeApiCall(url);
      const items = response.data.value || [];
      // Eklenme tarihine g√∂re azalan sƒ±rala (en yeni en √ºstte)
      items.sort((a, b) => {
        const aTime = new Date(a.createdDateTime).getTime();
        const bTime = new Date(b.createdDateTime).getTime();
        return bTime - aTime;
      });
      return {
        total: items.length,
        items: items.slice(0, limit)
      };
    } catch (error) {
      throw error;
    }
  }

  /**
   * Geli≈ümi≈ü arama (sadece basit filtreleme ile)
   */
  async advancedSearch(options) {
    // Sadece query ve fileType destekliyoruz, diƒüerleri i√ßin ek geli≈ütirme gerekir
    return this.searchFiles(options.query, options.fileType, options.pageSize || 50);
  }

  /**
   * Dosya bilgisi getir
   */
  async getFileInfo(fileId) {
    try {
      const url = `${this.baseUrl}/me/drive/items/${fileId}`;
      const response = await this.makeApiCall(url);
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  /**
   * G√∂r√ºnt√ºleme linki olu≈ütur
   */
  async createViewLink(fileId) {
    try {
      const url = `${this.baseUrl}/me/drive/items/${fileId}/createLink`;
      const response = await this.makeApiCall(url, {
        method: 'POST',
        data: { type: 'view' }
      });
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Payla≈üƒ±m linki olu≈ütur
   */
  async createShareLink(fileId, permission = 'view') {
    try {
      const url = `${this.baseUrl}/me/drive/items/${fileId}/createLink`;
      const response = await this.makeApiCall(url, {
        method: 'POST',
        data: { type: permission === 'write' ? 'edit' : 'view' }
      });
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Dosya indir
   */
  async downloadFile(fileId, fileName) {
    const fs = require('fs');
    const path = require('path');
    const Utils = require('./utils');
    try {
      const url = `${this.baseUrl}/me/drive/items/${fileId}/content`;
      const response = await this.makeApiCall(url, {
        responseType: 'stream'
      });
      const safeName = Utils.sanitizeFileName(fileName);
      const filePath = path.join(process.cwd(), safeName);
      const writer = fs.createWriteStream(filePath);
      response.data.pipe(writer);
      await new Promise((resolve, reject) => {
        writer.on('finish', resolve);
        writer.on('error', reject);
      });
      return filePath;
    } catch (error) {
      throw error;
    }
  }

  /**
   * Dosya √∂nizleme linki al
   */
  async getFilePreview(fileId) {
    try {
      const url = `${this.baseUrl}/me/drive/items/${fileId}`;
      const response = await this.makeApiCall(url);
      
      // Dosya bilgisinden web URL'i al
      if (response.data.webUrl) {
        return {
          getUrl: response.data.webUrl
        };
      } else {
        throw new Error('Dosya i√ßin √∂nizleme URL\'i bulunamadƒ±');
      }
    } catch (error) {
      throw error;
    }
  }
}

module.exports = OneDriveAPI; 